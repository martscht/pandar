---
title: "Exploratorische Faktorenanalyse" 
type: post
date: '2020-03-25' 
slug: fue-efa 
categories: ["FuE II"] 
tags: ["EFA", "exploratorisch", "latent", "Hauptachsenanalyse"] 
subtitle: 'EFA'
summary: 'In diesem  Beitrag wird eine exploratorische Faktorenanalyse an Hand des Beispiels von Fragebogendaten zu den Big-5 durchgeführt. Der Unterschied verschiedener Faktorenmodelle mit ein bis drei Faktoren wird exploriert, um sich für ein passend sparasames Modell zu entscheiden.' 
authors: [irmer, schultze] 
weight: 1
lastmod: '`r Sys.Date()`'
featured: no
banner:
  image: "/header/brain.png"
  caption: "[Courtesy of pxhere](https://pxhere.com/en/photo/1370218)"
projects: []
reading_time: false
share: false

links:
  - icon_pack: fas
    icon: book
    name: Inhalte
    url: /lehre/fue-ii/fue-efa
  - icon_pack: fas
    icon: terminal
    name: Code
    url: /lehre/fue-ii/fue-efa.R
  - icon_pack: fas
    icon: pen-to-square
    name: Übungsdaten
    url: /daten/Big5_EFA.rda
output:
  html_document:
    keep_md: true
---

```{r setup, cache = FALSE, include = FALSE, purl = FALSE}
if (exists("figure_path")) {
  knitr::opts_chunk$set(fig.path = figure_path)
}
# Aktuell sollen die global options für die Kompilierung auf den default Einstellungen gelassen werden
library(ggplot2) # ggplot2 und dplyr werden nur für Grafiken benötigt
```

Forscher:innen der Psychologie oder anderer Natur-, Sozial- und Geisteswissenschaften interessieren sich häufig dafür, wie sich Daten auf einige wenige entscheidende Faktoren herunterbrechen lassen, welche  ein theoretisches Erklärungsmodell für die Variation in einem Datensatz liefern. Die Annahme ist hierbei, dass die beobachtbaren Messungen eine Linearkombination (also eine Summe) aus einem systematischen (wahren) und einem unsystematischen (Fehler-)Anteil bilden. Die dahinterliegenden Faktoren sind nicht messbare (latente) Variablen, auf welche, unter gewissen Annahmen, nur anhand der Kovariation zwischen den beobachtbaren Items geschlossen werden kann. Durch diese Zusammenhänge zwischen den Messungen können schließlich Hypothesen für die latenten Variablen untersucht werden. Ein theoriegenerierendes Verfahren, das hierzu häufig verwendet wird, ist die **exploratorische Faktorenanalyse**  (im Folgenden EFA, engl. **E**xploratory **F**actor **A**nalysis, vgl. [Eid, Gollwitzer & Schmitt, 2017](https://ubffm.hds.hebis.de/Record/HEB366849158), Kapitel 25. Außerdem können Sie sich [Brandt, 2020](https://ubffm.hds.hebis.de/Record/HEB468515836), Kapitel 23 genauer ansehen, wenn Sie weitere Informationen, bzw. eine zusätzliche Erklärung wünschen).

Wir wollen die **EFA** zur Auswertung von Beziehungen zwischen Variablen in `R` näher kennenlernen. Die EFA ist manchen Gesichtspunkten, sowie im Output in `R`, recht verwandt mit der [Hauptkomponentenanalyse (PCA)](/lehre/fue-i/pca) aus dem vergangenen Semester. Allerdings konnten wir bei der PCA kein Erklärungsmodell aufstellen ("wir konnten den Hauptkomponenten nicht so einfach eine inhaltliche Bedeutung zuschreiben") und auch keine Messfehler (unsystematische Fehleranteile) mitmodellieren. Zudem waren die Hauptkomponenten der PCA Linearkombinationen (also Zusammensetzungen) aus den beobachteten Variablen, bei der EFA hingegen sind die Messungen (beobachteten Variablen) Linearkombinationen aus systematischen (latenten) Variablen sowie Messfehlern.

Bevor wir mit den Analysen beginnen können, laden wir zunächst alle Pakete, welche wir im Folgenden benötigen werden.
```{r, message=F}
library(corrplot) # Korrelationsmatrix grafisch darstellen
library(psych) # EFA durchführen
library(GPArotation) # EFA Lösung rotieren
```


## Datensatz

Wir wollen uns die Faktorenstruktur der *Big-5* eines entsprechenden Fragebogens ansehen. Der Originaldatensatz ist ein Onlinedatensatz, wird seit 2012 erfasst und ist auf [<i class="fas fa-download"></i> openpsychometrics.org](https://openpsychometrics.org/_rawdata/) als *.zip* downloadbar. Bisher haben über **19700** Proband:innen aus der ganzen Welt daran teilgenommen. Zu jeder der fünf Facetten gibt es 10 Fragen. Der Fragebogen ist auf [personality-testing.info](http://personality-testing.info/tests/BIG5.php) einzusehen.
Um das Ganze etwas übersichtlicher zu gestalten, betrachten wir einen gekürzten Datensatz. Wir kennen diesen Datensatz, allerdings in anderer Zusammensetzung, bereits aus den [Übungen zum vergangenen Semester](/lehre/fue-i/msc1-daten) zum Themenblock [MANOVA](/lehre/fue-i/manova), weswegen wir hier das Kürzel "EFA" angehängt haben. Im Datensatz *Big5_EFA.rda* befinden sich 15 Items aus dem Big-5 Persönlichkeitsfragebogen. Hier werden von diesen 10 Items jeweils die ersten drei verwendet. Der Itemwortlaut der verwendeten Items ist wie folgt:

```{r, echo = F, purl=FALSE}
library(htmlTable)
output <- c(c("E1", "I am the life of the party.",
"E2", "I don't talk a lot.",
"E3", "I feel comfortable around people.",
"N1", "I get stressed out easily.",
"N2", "I am relaxed most of the time.",
"N3", "I worry about things.",
"A1", "I feel little concern for others.",
"A2", "I am interested in people.",
"A3", "I insult people.",
"C1", "I am always prepared.",
"C2", "I leave my belongings around.",
"C3", "I pay attention to details.",
"O1", "I have a rich vocabulary.",
"O2", "I have difficulty understanding abstract ideas.",
"O3", "I have a vivid imagination."))
output <- matrix(output, ncol = 2, nrow = 3*5, byrow = T)
htmlTable(output, header =  paste(c("Item Nr.", "Item")),
         caption="Itemwortlaut", align = "cl")
```

Die Kürzung des vollen Datensatzes lässt sich im [Appendix A](#AppendixA) nachvollziehen. Zusätzlich zu den Persönlichkeitsitems wurden demografische Daten, die mögliche Unterschiede zwischen Personen beschreiben, erfasst.

### Daten laden
Wir laden zunächst die Daten: entweder lokal von Ihrem Rechner:

```{r, eval = F}
load("C:/Users/Musterfrau/Desktop/Big5_EFA.rda")
```

oder wir laden sie direkt über die Website:

```{r}
load(url("https://pandar.netlify.app/daten/Big5_EFA.rda"))
```

Nun sollte in `R`-Studio oben rechts in dem Fenster unter der Rubrik "Data" unser Datensatz mit dem Namen "_Big5_" erscheinen. Der Datensatz heißt also genauso wie der Datensatz für die [MANOVA](../../fue-i/manova), enthält aber andere Variablen (also _Achtung!_).

### Übersicht über die Daten

```{r data}
head(Big5, n = 10) # gebe die ersten 10 Zeilen aus
```

Wir sehen, dass in den ersten 4 Spalten die demografischen Daten wie etwa  *Alter ("age")*, *Englisch als Muttersprache ("engant", 1=yes, 2=no, 0=missed)*, *Geschlecht ("gender", 1=Male, 2=Female, 3=Other, 0=missed)* und *Herkunftsland ("country", ISO-kodiert, bspw. "DE" = Deutschland, "FR" = Frankreich, "EM" = Vereinigte Arabische Emirate, "US" = Vereinigten Staaten von Amerika)* eingetragen wurden. In den darauf folgenden Spalten sind die Items der Extraversion (engl. *extraversion*, Items: *E1*, *E2*, *E3*), des Neurotizismus (engl. *neuroticism*, Items: *N1*, *N2*, *N3*), der Verträglichkeit (engl. *agreeableness*, Items: *A1*, *A2*, *A3*), der Gewissenhaftigkeit  (engl. *conscientiousness*, Items: *C1*, *C2*, *C3*) und der Offenheit für Erfahrungen (engl. *openness*, Items: *O1*, *O2*, *O3*) eingetragen. Beispielsweise ist die erste Person des Datensatzes ein 53-jähriger Mann, der Englisch als Muttersprache spricht und in den USA lebt.


Da wir uns in der Praxis nur sehr selten in der glücklichen Lage befinden, einen solch riesigen Datensatz zu haben, wollen wir uns innerhalb des Datensatzes auf Subgruppen beschränken: wir wollen uns zunächst nur Daten von Personen aus *Frankreich* ansehen. Dazu wählen wir nur diejenigen Zeilen aus, in denen `country == "FR"` gilt. Das erreichen wir wie folgt: Mit `Big5$country` haben wir Zugriff auf die "Country"-Spalte im Datensatz und können mit `== "FR"` prüfen, an welchen Stellen hier  *"FR"* steht, also Personen, die in Frankreich leben. `dim` gibt die Dimensionen des Datensatzes wieder.

```{r}
dim(Big5)
data_France <- Big5[Big5$country == "FR", ]
dim(data_France)
```


Dem Output sollte zu entnehmen sein, dass `data_France` `r dim(data_France)[1]` Zeilen (also Proband:innnen, die in Frankreich leben) und `r dim(data_France)[2]` Spalten (also Variablen) enthält. Für die weiteren Analysen brauchen wir die demografischen Variablen in dem Datensatz der in Frankreich lebenden Teilnehmer:innen nicht mehr. Aus diesem Grund speichern wir den Datensatz noch einmal ohne die ersten 4 Spalten ab. Anschließend stellen wir die Korrelationsmatrix dieser Daten grafisch dar (den Befehl `corrplot` aus dem gleichnamigen Paket kennen wir bereits aus der [PCA](/lehre/fue-i/pca) Sitzung des vergangenen Semesters).

```{r fig.align="center"}
dataFR <- data_France[, -c(1:4)] # entferne demografische Daten und speichere als "dataFR"

#### Visualisierte Korrelationsmatrix in dataFR
corrplot(corr = cor(dataFR), # Korrelationsmatrix (Datengrundlage)
         method = "color", # zeichne die Ausprägung der Korrelation farblich kodiert
         addCoef.col = "black", # schreibe die Korrelationskoeffizienten in schwarz in die Grafik
         number.cex = 0.7) # stelle die Schriftgröße der Koeffizienten ein

```

Auf den ersten Blick scheinen die Items der gleichen Skala (ausgedrückt durch gleiche Buchstaben pro Item) stärker (betragsmäßig höher) miteinander zu korrelieren. Allerdings sind hier sehr viele Korrelationen abgetragen. Wir wollen uns zunächst nur auf Extraversion und Neurotizismus beschränken.


```{r}
dataFR2 <- dataFR[,1:6] # Zunächst wählen wir die ersten 6 Items: E1 bis E3 und N1 bis N3
head(dataFR2)
# zum gleichen Ergebnis würde auch Folgendes kommen (besonders von Relevanz,
# wenn wir bspw. nicht die Position sondern nur die Namen der Variablen kennen!):
head(dataFR[, c("E1", "E2", "E3", "N1", "N2", "N3")])
```


Wenn wir uns die Korrelationmatrix des gekürzten Datensatzes `dataFR2` ansehen...


```{r  fig.align="center"}
# Visualisierte Korrelationsmatrix
corrplot(corr = cor(dataFR2), # Korrelationsmatrix (Datengrundlage)
         method = "color", # Zeichne die Ausprägung der Korrelation farblich kodiert
         addCoef.col = "black", # schreibe die Korrelationskoeffizienten in schwarz in die Grafik
         number.cex = 1) # Stelle die Schriftgröße der Koeffizienten ein
```

...erkennen wir deutlich, dass die Extraversionsitems und die Neurotizismusitems untereinander jeweils stärker zusammenhängen als zwischen den Konstrukten. Dennoch ist der Grafik zu entnehmen, dass die beiden Konstrukte nicht unabhängig voneinander sind (es gibt Beziehungen zwischen Items der beiden Konstrukte).


## Ziel: EFA
Unser Ziel ist es, mit den gegebenen Items eine exploratorische Faktorenanalyse durchzuführen. Wir wollen hierbei die Anzahl der Faktoren mittels einer Parallelanalyse bestimmen und anschließend dieses Modell mit dem $\chi^2$-Test (*Likelihood-Quotiententest (Likelihood-Ratio-Test)/ Likelihood-Differenzentest*/ $\chi^2$-*Differenzentest*) gegen konkurrierende Modelle testen.
Hierbei wollen wir die oblique rotierte und die orthogonal rotierte Lösung vergleichen und hinsichtlich unserer Daten interpretieren. Das Modell, was wir an unsere Daten anpassen wollen, sieht für 6 Variablen ($V_1,\dots,V_6$) im Allgemeinen erst einmal so aus (hier sind nur die Beziehungen, nicht aber die Stärken der Beziehungen zwischen den Variablen abgetragen), wobei hier schon die implizite Annahme drin steckt, dass es nur zwei zugrundeliegende latente Variablen gibt:


<img src = "https://raw.githubusercontent.com/martscht/PsyMSc1/master/inst/tutorials/EFA/images/EFA_Modell.png" width="70%"/>


Auf unseren Datensatz angepasst, wollen wir folgendes Modell anpassen:

<center> <img src = "https://raw.githubusercontent.com/martscht/PsyMSc1/master/inst/tutorials/EFA/images/specific_model.png" width="70%"/> </center>


Natürlich erwarten wir, dass insgesamt 2 Faktoren die Daten am besten beschreiben und dass die konstruktkongruenten Items jeweils auf dem gleichen Faktor am stärksten laden. Aber stützen die Daten diese Hypothese?

Wir wollen im Folgenden

- eine Parallelanalyse durchführen, um in Erfahrung zu bringen, wie viele Faktoren sinnvoll zu den Daten passen
- eine Hauptachsenanalyse mit orthogonaler und obliquer Rotation durchführen
- eine exploratorische Maximum-Likelihood-Faktorenanalyse durchführen und die Passung zu den Daten untersuchen
- im Rahmen  der exploratorischen Maximum-Likelihood-Faktorenanalyse die Passung zu den Daten im Vergleich zu konkurrierenden Modellen untersuchen.

### Parallelanalyse und Auswahl an Faktoren {#Parallelanalyse_1}
Zur Auswahl der Anzahl an Faktoren in der EFA kann auf die Eigenwerte zurückgegriffen werden. Diese Eigenwerte entstehen beispielsweise durch Lösen des Eigenwerteproblems und entsprechen den Varianzen der Faktoren. Hier gilt es, nur solche Faktoren zu wählen, die auch große Varianzen haben.
Die Parallelanalyse hatten wir im Zusammenhang mit der [Hauptkomponentenanalyse](/lehre/fue-i/pca) kennengelernt. Hier werden vielfach (z.B. 1000 Mal, für Vergleichbarkeit sogar besser mehr!) unabhängige Daten in dem gleichen Format des ursprünglichen Datensatzes gezogen und eine PCA oder EFA durchgeführt. Die entstehenden Eigenwerte werden der Größe nach sortiert und dann über die Wiederholungen gemittelt. So entsteht ein auf die Stichprobe und Anzahl der Variablen genormter, zufälliger, durchschnittlicher Eigenwerteverlauf. Sind Eigenwerte der tatsächlich beobachteten Daten größer als die der Parallelanalyse, so spricht dies für eine/n bedeutsame/n Komponente/Faktor. Weitere Kriterien zur Auswahl von zu extrahierenden Faktoren im Rahmen der PCA waren das *Eigenwerte-größer-1 Kriterium (Kaiser-Guttman-Kriterium)* sowie der *Scree-Test (Elbow-Criterion, Knick im Eigenwerteverlauf)*. Weitere Informationen zur EFA sowie zu Wiederholungen der PCA und der Auswahlkriterien können beispielsweise in [Eid, Gollwitzer und Schmitt (2017)](https://ubffm.hds.hebis.de/Record/HEB366849158) in Kapitel 25 (Seite 919 und folgend) nachgelesen werden.

Der wesentliche Unterschied zwischen einer EFA und einer PCA ist, dass bei der EFA angenommen wird, dass die beobachteten Variablen systematische (wahre) und unsystematische (Fehler-) Anteile enthalten. Es wird somit ein Erklärungsmodell, welches  die Variation zwischen den Variablen erzeugt, postuliert. Bei der PCA werden die beobachteten Variablen als messfehlerfrei angenommen. Eine wichtige Folge aus der (Nicht-) Modellierung der Fehler ist, dass in der Regel die Faktorladungen bei der PCA höher ausfallen als bei der EFA. Dies liegt daran, dass bei der PCA die Variablen mit ihren eigenen Messfehlern, aus welchen auch die Hauptkomponenten unter anderem zusammengesetzt sind, korrelieren. Die Faktorladungen/ Komponentenladungen stehen hierbei (im orthogonalen Fall) für die Korrelation zwischen Item und Faktor/ Komponente; im obliquen Fall sind die Faktorladungen als Regressionkoeffizienten zu interpretieren. Wird eine ML-EFA an die Daten angepasst, so wird zusätzlich noch ein Erklärungsmodell basierend auf Verteilungsannahmen (multivariate Normalverteilung der Faktoren und Fehler --- und als Konsequenz daraus auch der Items) herangezogen. Bei der PCA sind die Hauptkomponenten lediglich Linearkombinationen aus den beobachteten Variablen ohne jegliche Verteilungsannahmen (die Hauptkomponenten bestehen aus gewichteten Summen der beobachteten Variablen). Entsprechend ist es bei der PCA auch nicht möglich, konkurierende Modelle gegeneinander zu testen. Es bleiben dort nur die deskriptiven und recht subjektiven Auswahlkriterien für die Anzahl der Komponenten.

Mit Hilfe des `fa.parallel`-Befehls aus dem `psych`-Paket, welchen wir im Rahmen der PCA bereits kennengelernt hatten, lässt sich ganz einfach der Eigenwerteverlauf inklusive Parallelanalyse grafisch darstellen.

```{r fig.align="center", warning=FALSE}
fa.parallel(dataFR2)
```
Ohne weitere Einstellungen wird der Eigenwerteverlauf der PCA und der EFA ausgegeben. Deutlich zu sehen ist, dass die Eigenwerte der PCA größer ausfallen als die der EFA. Dies liegt erneut daran, dass die Faktoren der EFA lediglich die systematischen Anteile der Variablen enthalten, während die Komponenten der PCA Kompositionen sind - also Zusammensetzungen aus den Variablen; inklusive der Messfehler. Wählen wir `fa = "fa"`, so wird uns nur der Verlauf der Eigenwerte auf Basis einer EFA aufgeführt.

```{r fig.align="center", warning=FALSE}
fa.parallel(dataFR2, fa = "fa")
```
Die Grafik zeigt drei Eigenwerteverläufe. *FA Actual Data* ist der Eigenwerteverlauf unseres Datensatzes. *FA Simulated Data* ist der Eigenwerteverlauf basierend auf den 1000 simulierten Datensätzen. *FA Resampled Data* ist der Eigenwerteverlauf von Datensätzen, der durch *Resampling*, also neues Verteilen unseres Datensatzes entsteht (das ist im Grunde [Bootstrapping](../sem#Bootstrapping), was im Rahmen der Sitzung zu [SEM](../sem) näher erläutert wird).

Der Parallelanalyse der EFA ist zu entnehmen, dass voraussichtlich 2 Faktoren genügen, um die Variation im Datensatz zu erklären. Auch die Parallelanalyse der PCA (Grafik zuvor) lässt dies vermuten. Des Weiteren sprechen beide Scree-Tests für einen Knick um den 3. Faktor/die 3. Komponente, was auch für eine Dimensionalität von 2 spricht. Zu guter Letzt zeigt auch das Kaiser-Guttman-Kriterium kein anderes Ergebnis. Allerdings ist dieses Kriterium nur sinnvoll auf den Eigenwerteverlauf der PCA anwendbar, weswegen wir es auch nur im Bezug auf den PCA-Eigenwerteverlauf interpretieren.

### Orthogonale und oblique Hauptachsenanalyse {#Hauptachsenanalyse}

Da unsere Auswahlkriterien einstimmig für 2 Faktoren sprechen und dies auch unsere Hypothese war, modellieren wir zunächst eine orthogonale Hauptachsenanalyse. Dazu nutzen wir den `fa` (Factor Analysis) Befehl des `psych`-Paketes. Mit Hilfe der Argumente `nfactors` und `rotate` lässt sich die Anzahl an Faktoren sowie die Rotation auswählen (genauso wie bei der `pca` Funktion für die PCA!). Wir wollen hier orthogonal varianzmaximierend (also *varimax*) rotieren.

```{r}
fa(dataFR2, nfactors = 2, rotate = "varimax")
```

Im Output ganz oben erkennen wir die Schätzmethode (hier: `minres`, also Minimierung der Residuen). Aus diesem Grund heißen die Faktoren in diesem Output auch *MR1* und *MR2*; für *Minimale-Residuen-Faktor 1* und *2* (diese Benennung war uns auch bereits bei der PCA aufgefallen, wo diese je nach Rotation entweder PC1 oder RC1, etc., hießen). Die Faktorladungen zu den zugehörigen Faktoren sind unter `Standardized loadings (pattern matrix) based upon correlation matrix` zu sehen. `h2` steht für die Kommunalität ($h^2$), also den Anteil an systematischer Variation, die auf die 2 Faktoren zurückzuführen ist (diese kann ähnlich der Reliabilität interpretiert werden). `u2` ist die "uniqueness" ($u^2$), also der unerklärte Anteil. Diese wird auch oft *Spezifität* genannt, da sie den für dieses Item spezifischen Varianzanteil beschreibt. Offensichtlich gilt $u^2 = 1-h^2$ oder $h^2 + u^2 = 1$. Unter den Faktorladungen erhalten wir Informationen über die Faktoren. `SS loadings` steht für "Sum of Squares loadings", also die Quadratsumme der Faktorladungen. Diese ist gleich dem Eigenwert: $\theta_j = \Sigma_{i=1}^p\lambda_{ij}^2 = \lambda_{1j}^2+\dots+\lambda_{pj}^2$ (Spaltenquadratsumme der Faktorladungen), mit $p=$ Anzahl an Variablen (hier $p=6$). Allerdings gilt dies nur für den orthogonalen Fall. Sind die Faktoren korreliert, muss diese Korrelation berücksichtigt werden. Dazu später mehr! `Proportion Var` betitelt den Anteil der Variation, der durch die jeweiligen Faktoren erklärt werden kann. `Cumulative Var` kumuliert, also summiert, diese Anteile bis zum jeweiligen Faktor auf ($\text{CumVar}_j = \sum_{k=1}^j\theta_k = \theta_1+\dots+\theta_j$, also $\text{CumVar}_1=\theta_1$ und $\text{CumVar}_2=\theta_1+\theta_2$). `Proportion Explained` setzt die Variation, die durch die Faktoren erklärt wird, in Relation zur gesamten erklärten Varianz (d.h. hier summiert sich die erklärte Varianz immer zu 1, während sich die proportionale Varianz nur zu 1 aufsummiert, wenn die gesamte Variation im Datensatz auf die beiden Variablen zurückzuführen ist). `Cumulative Proportion` beschreibt das gleiche wie `Cumulative Var`, nur bezieht sie sich hier auf die `Proportion Explained`. Bei der Interpretation dieser Kennwerte ist zu bedenken, dass bei der EFA angenommen wird, dass die beobachteten Variablen Messfehler enthalten (also die Reliabilität nicht als 1 angenommen werden kann). Folglich ist die Kommunalität $h^2$ nicht 1 und wir können nicht unbedingt davon ausgehen, dass die Faktoren die gesamte Variation der Daten erklären. All diese Koeffizienten kennen wir bereits aus der Sitzung zur [PCA](../../fue-i/pca), wo wir diese im Hinblick auf eine PCA interpretierten. Dabei fiel uns auch auf, dass einige Koeffizienten in dieser Übersicht nicht mit allen Dezimalstellen angezeigt werden und es ggf. zu seltsamen Rundungsverfälschungen kommen kann. Aus diesem Grund hatten wir uns entschieden, die jeweiligen Koeffizienten und Informationen dem Objekt selbst zu entlocken, um diese Rundungsverfälschungen zu umgehen.

Außerdem werden  durch diesen Befehl sehr viele Informationen ausgegeben. Aus diesen Gründen speichern wir uns diese Analyse als ein Objekt ab, welchem wir dann gezielt Informationen mit Hilfe von `...$...` entlocken können. Welche Argumente entlockt werden können, kann beispielsweise mit `names` herausgefunden werden. Wir speichern das Objekt unter dem Namen *two_factor* ab.


```{r}
two_factor <- fa(dataFR2, nfactors = 2, rotate = "varimax")
names(two_factor) # mögliche Informationen
```

Beispielsweise erhalten wir mit `$loadings` die Faktorladungsmatrix sowie Informationen über die Eigenwerte. (*Wichtig für später*: Die richtigen Kommunalitäten werden mit `$communality` angefordert.)

```{r}
two_factor$loadings
```


Hier ist relativ deutlich die Zuordnung zu den jeweiligen Faktoren zu sehen. Faktor 1 (*MR1*) entspräche *post-hoc* interpretiert (die Theorie wird also aus den Daten generiert; es sind auch andere Interpretationsansätze zulässig) der Extraversion, während der zweite Faktor (*MR2*) dem Neurotizismus entspräche. Indem wir hinter `loadings` eckige Klammern mit einem Komma setzten (`[,]`), bekommen wir alle Nachkommastellen ohne Runden angzeigt (hätten wir bspw. `round` auf die Ladungsmatrix oben angewendet, würden sich auch die Eigenwerte ändern, weswegen diese Ansicht sich nicht wirklich zur genauen Interpretation der Eigenwerte eignet! Hier hatten wir das Argument `Vaccounted` bereits im Rahmen der [PCA](../../fue-i/pca) kennengelernt):

```{r}
two_factor$loadings[,] # ohne seltsames Runden
```


Die Faktorladungsmatrix wird auch manchmal *Mustermatrix* genannt. Die *Strukturmatrix* enthält Informationen über die Korrelation der Items mit den jeweiligen Faktoren. Sie heißt `Structure`. Auch hier ist der Zusatz `[,]` sinnvoll!

```{r}
two_factor$Structure[,]
```

Wir sehen deutlich, dass die Strukturmatrix sich nicht von der Faktorladungsmatrix unterscheidet. Das liegt daran, dass die Faktoren noch als unkorreliert angenommen werden: somit ist die Faktorladungsmatrix gleich der Strukturmatrix. Genau aus diesem Grund hatten wir uns die Strukturmatrix auch nicht im Rahmen der PCA angesehen --- dort hatten wir nur orthogonal rotiert.

Da wir nicht davon ausgehen können, dass die Faktoren unkorreliert sind, wollen wir die gleiche Analyse nun für *oblique* ("oblimin" in `R`) rotierte Faktoren durchführen.


```{r}
two_factor_oblimin <- fa(dataFR2, nfactors = 2, rotate = "oblimin")
```

Die einzig neue Information können wir unter `With factor correlations of` ablesen: die Korrelation zwischen den Faktoren. Im Output der obliquen Rotation ist zu erkennen, dass sich die Kommunalitäten nicht ändern. Wir können also nicht mehr Variation im Datensatz erklären. Die Varianz wird nur umverteilt, wie den veränderten Eigenwerten neben `SS loadings` zu entnehmen ist. Hier hat der erste Faktor einen etwas größeren Eigenwert als im orthogonalen Fall (entsprechend ist der 2. Eigenwert kleiner, da nicht mehr Variation erklärt wird):  

```{r}
two_factor$Vaccounted
two_factor_oblimin$Vaccounted
```

Schauen wir uns die Ladungsmatrix an, ...
```{r}
two_factor_oblimin$loadings[,] # Ladungsmatrix
```
... so ist *post-hoc* interpretiert anzunehmen, dass der erste Faktor die Extraversion abbildet und der zweite den Neurotizismus.

Entlocken Sie doch mal dem Objekt `two_factor_oblimin` die latente Kovarianzmatrix, also die Kovarianzmatrix der latenten Variablen. Tipp, der griechische Buchstabe in diesem Zusammenhang ist häufig $\Phi$. Die resultierende Matrix sieht so aus:

```{r, echo = F, purl=FALSE}
two_factor_oblimin$Phi
```


Als neue Information entnehmen wir der Korrelationsmatrix der Faktoren, dass die beiden Faktoren negativ korreliert sind zu `r round(two_factor_oblimin$Phi[2], 2)`. Nun wollen wir nachschauen, ob sich tatsächlich die Strukurmatrix im oblique-rotierten Fall von der Faktorladungsmatrix unterscheidet:




```{r}
two_factor_oblimin$loadings[,]
two_factor_oblimin$Structure[,]
```

Sie sehen, dass sich nun die Strukturmatrix von der Faktorladungsmatrix unterscheidet. Die Unterschiede sind allerdings nicht sehr groß, da die Korrelation zwischen den beiden Faktoren mit `r round(two_factor_oblimin$Phi[2], 2)` betragsmäßig nicht sonderlich groß ausfällt. Weitere Informationen und wie die beiden Matrizen ineinander überführbar sind, erfahren Sie im [Appendix C](#AppendixC). In [Appendix D](#AppendixD) erfahren Sie, wie Sie Kommunalitäten und Eigenwerte im Rahmen der EFA nur mit Hilfe der `loadings` und der Faktorkorrelation `Phi` bestimmen. Falls Sie sich nun zu Recht wundern, dass [Appendix B](#fivefactorML) fehlt, dann sei gesagt, dass dieser alle Analysen am vollständigen Datensatz durchführt und es durch die Abhängigkeiten der Daten in den Appendizes Sinn macht, diesen zwar im Text später zu erwähnen aber inhaltlich vorzuziehen.

Die Frage ist nun, ob unser Modell überhaupt zu den Daten passt.


### Exploratorische Maximum-Likelihood-Faktorenanalyse (ML-EFA)
Wir möchten unsere Analysen nun gegen andere konkurrierende Modelle absichern sowie untersuchen, ob unser zweifaktorielles Modell überhaupt zu den Daten passt. Hierzu müssen wir annehmen, dass unsere Daten multivariat normalverteilt sind. Wie man diese Annahme zumindest deskriptiv untersucht, hatten wir im Zusammenhang mit den Voraussetzungen von statistischen Verfahren kennengelernt (Mahalanobisdistanz sollte approximativ $\chi^2$-verteilt sein, siehe hierzu im [Appendix E](#AppendixE) nach, auch weitere Tests sind möglich: bspw. Mardia's Test). Mit Hilfe dieser Verteilungsannahme können wir die Maximum-Likelihood-Schätzmethode nutzen, um die Parameter in unserem Modell zu schätzen. Die *Likelihood* ist die Wahrscheinlichkeit unserer Daten, gegeben das Modell. Sie hängt somit von den beobachteten Daten ab (den Ausprägungen der Personen auf den Variablen), hat die Gestalt unseres Modells und wird parametrisiert durch die Parameter in unserem Modell. Die durch das Modell implizierte Kovarianz oder Korrelationsmatrix der beobacheten Variablen wird mit $\Sigma$ betitelt und setzt sich folgendermaßen zusammen:

$$\Sigma := \Lambda\Phi \Lambda' + \Theta.$$
Dabei ist $\Lambda$ die Matrix der Faktorladungen, $\Phi$ die Kovarianz- oder Korrelationsmatrix der Faktoren und $\Theta$ die Kovarianzmatrix der Fehler.

Im unkorrelierten/orthogonalen Fall sähe die Matrix so aus: $\Sigma := \Lambda \Lambda' + \Theta$, da hier $\Phi$ die Einheitsmatrix ist und $\Lambda$ demzufolge einfach mit 1 multipliziert wird! Diese ist somit sehr nah an der implizierten Matrix im Rahmen der PCA, welche sich durch $\Lambda \Lambda'$ ergab. Wir erkennen erneut, dass bei der PCA die Messfehler nicht mitmodelliert werden (deren Varianzen stecken in $\Theta$).

Unter der Normalverteilungsannahme brauchen wir nur (Ko-)Varianzen und Mittelwerte, um unsere Variablen vollständig zu beschreiben. In der Schätzung der ML-EFA geht es uns darum, die Parameter in $\Lambda$, $\Phi$ und $\Theta$ so zu bestimmen, dass sich die behauptete Kovarianzmatrix $\Sigma$ von unserer beobachteten Kovarianzmatrix $S$ so wenig unterscheidet wie möglich. Dazu bestimmen wir mit der Maximum-Likelihood-Schätzung die Werte für z.B. Faktorladungen, die es *maximal wahrscheinlich* machen, dass unsere Daten enstehen würden, wenn unsere EFA das richtige Modell wäre.

Um mit Hilfe von `fa` eine ML-EFA durchzuführen, muss dem Argument `fm` die entsprechende Bezeichnung `"ml"` übergeben werden.

```{r}
two_factor_ML <- fa(dataFR2, nfactors = 2, rotate = "oblimin", fm = "ml")
two_factor_ML
```

Wir sehen, dass diesmal die Schätzmethode "ml" ist. Auch die Faktoren heißen nun *ML1* und *ML2*. Die Faktorladungen im ML-EFA Modell mit *obliquer* Rotation sehen den Faktorladungen aus unserer vorigen Analyse sehr ähnlich.

Uns interessiert nun die Modellpassung, also inwiefern unsere Daten von unserem behaupteten Modell abweichen. `$STATISTIC` und `$PVAL` entlocken der Analyse (abgespeichert als Objekt) den $\chi^2$-Wert und den zugehörigen p-Wert bei `r fa(dataFR2, nfactors = 2, rotate = "oblimin", fm = "ml")$dof` Freiheitsgraden. Verwirrenderweise gibt es zusätzlich `$chi`, was den empirisch und nicht likelihoodbasierten $\chi^2$-Wert ausgibt, welcher sinnvoll ist, wenn Modellvoraussetzungen nicht erfüllt sind.

```{r}
two_factor_ML$STATISTIC # Likelihood basierter Chi²-Wert
two_factor_ML$PVAL # p-Wert
```

Dem ist zu entnehmen, dass auf dem Signifikanzniveau von 5% die Hypothese auf Passung der Kovarianz unserer Daten mit der modellimplizierten Kovarianz in der Population nicht verworfen wird.  Die Daten widersprechen dem zweifaktoriellen Modell nicht (die untersuchte Null-Hypothese ist: $H_0: \Sigma_{Daten}=\Sigma_{2-fakt.}$, also, dass die Datenkovarianzmatrix sich durch die Kovarianzmatrix eines 2-faktoriellen EFA-Modells darstellen lässt). Vielleicht reicht auch ein Faktor aus, um die Variation in unserem Datensatz zu beschreiben? Wir wollen unser Modell mit zwei Faktoren gegen eines mit einem und eines mit drei Faktoren absichern.

### Modellvergleich: ML-EFA

Das einfaktorielle Modell erhalten wir ganz einfach via:

```{r}
one_factor_ML <- fa(dataFR2, nfactors = 1, rotate = "oblimin", fm = "ml")
one_factor_ML$STATISTIC # Chi²-Wert
one_factor_ML$PVAL # p-Wert
```

Das einfaktorielle Modell scheint nicht zu den Daten zu passen (*Mit einer Irrtumswahrscheinlichkeit von 5% ist davon auszugehen, dass in der Population die Differenz zwischen der Populationskovarianzmatrix und der modellimplizierten Kovarianzmatrix, bzw. der daraus folgenden Likelihoods, nicht 0 ist.*). Dennoch wollen wir dies genau wissen und vergleichen die beiden Modelle direkt miteinander. Für einen solchen Vergleich ist es notwendig, dass es sich bei den beiden Modellen um *geschachtelte Modelle* handelt. Das bedeutet, dass ein Modell durch Restriktionen von Modellparametern aus dem anderen Modell erzeugt werden kann. Das einfaktorielle Modell lässt sich aus dem zweifaktoriellen Modell durch die Restriktion gewinnen, dass alle Ladungen auf dem Faktor 0 sind und die Varianz dieses Faktors dementsprechend ebenfalls 0 ist.

Mit Hilfe des `anova`-Befehls, welchen wir schon bei einigen anderen Modellvergleichen im Rahmen der [Regression](/lehre/fue-i/regression-ausreisser-fue), der [logistischen Regression](/lehre/fue-i/logistische-regression-titanic) sowie der [Multi-Level Modelle](/lehre/fue-i/hierarchische-regression-schule) kennengelernt haben, lässt sich nun das einfaktorielle mit dem zweifaktoriellen Modell vergleichen.

```{r, results='hide'}
anova(one_factor_ML, two_factor_ML)
```

```{r, echo = F, purl=FALSE}
knitr::kable(anova(one_factor_ML, two_factor_ML), row.names = T)
```

Zunächst bekommen wir angezeigt, welche Modelle unter welchem Kürzel gegeneinander getestet werden. Die Modellnummer steht im ANOVA-Output entsprechend für das jeweilige Modell. In der Zeile `2` steht also der Output für das 2-faktorielle Modelle und am Ende dieser Zeile steht auch der Modellvergleich.

In der ersten Spalte stehen beispielsweise die Freiheitsgrade der Modelle (`df`). Daneben steht die Differenz der Freiheitsgrade (`d.df`) und dahinter stehen verschiedene Fit-Maße, bzw. Modellvergleiche. Wir müssen im Bereich des *chiSq* und nicht bei *empirical* (eine Näherung des $\chi^2$ Wertes, wenn Annahmen verletzt sind) nachsehen. Der Output ist immer so aufgebaut, dass zunächst der Wert pro Modell (`chiSq` oder `empirical`) angezeigt wird und anschließend die Differenz (`d.chiSq` oder `d.empirical`) sowie die Signifikanzentscheidung berichtet werden (`PR test`, welche allerdings nicht bei der Näherung angezeigt wird). Außerdem wird noch eine Rubrik `test`, bzw. `test.echi` angezeigt, welche noch einmal die $\chi^2$-Differenz geteilt durch die Freiheitsgrade repräsentiert. Der $\chi^2$-Differenzwert liegt bei `r round(anova(one_factor_ML, two_factor_ML)[[4]][2], 3)` mit einem zugehörigen p-Wert von de facto `r round(anova(one_factor_ML, two_factor_ML)[[5]][2], 7)`. `d.df` (häufig $\Delta df$) gibt die Anzahl an Freiheitsgraden der $\chi^2$-Differenz (hier: df = `r anova(one_factor_ML, two_factor_ML)[[2]][2]`) des Differenzentests an (hier wurden die Freiheitsgrade der beiden Modelle voneinander abgezogen). Ganz hinten wird noch das Bayes Information Criterion `BIC`, sowie dessen Differenz `d.BIC` aufgeführt. Dieses Informationskriterium werden wir bei der [CFA](../fue-ii/fue-cfa) und deren Modellpassung noch einmal genauer betrachten.

Insgesamt wird die Null-Hypothese, dass beide Modell die Daten gleich gut beschreiben, verworfen. Wir entscheiden uns --- Ockhams Rasiermesser folgend (siehe [Eid et al., 2017, p. 787](https://ubffm.hds.hebis.de/Record/HEB366849158)) --- somit für das Modell mit mehr Parametern - das weniger restriktive Modell - welches die Daten besser beschreibt: hier das zweifaktorielle Modell. Nun ist die Frage, ob wir das Modell noch weiter verbessern können, indem wir drei anstatt zwei Faktoren verwenden, um die Kovariation zwischen den Variablen zu beschreiben.  


```{r}
# Passt auch eines mit 3 Faktor?
three_factor_ML <- fa(dataFR2, nfactors = 3, rotate = "oblimin", fm = "ml")
three_factor_ML$STATISTIC # Chi²-Wert
three_factor_ML$PVAL # p-Wert
```

Das dreifaktorielle Modell beschreibt die Daten perfekt. Das liegt daran, dass es im dreifaktoriellen Modell genauso viele Parameter gibt, wie es empirische Informationen im Datensatz gibt. Demnach lässt sich die empirische Korrelationsmatrix perfekt durch die modelltheoretische Korrelationsmatrix (diejenige Korrelationsmatrix, die sich ergibt, wenn nur die Beziehungen zwischen den Variablen bestehen, die durch das Modell angenommen werden) darstellen. Ein Test auf Modellpassung ist in diesem Fall nicht möglich und auch nicht nötig (deshalb wird beim `$PVAL` nichts bzw. `NA` ausgegeben). Nun vergleichen wir die beiden Modelle (es ist sehr sinnvoll, das komplexere Modell rechts hin zuschreiben, da es ansonsten bei manchen Analysemethoden zu negativen $\chi^2$-Werten kommen kann, außerdem zeigt  man damit auf, wie die Schachtelung der Modelle funktioniert [allerdings sichert dies nicht die Schachtelung, dies ist eine theoretische Überlegung, die die Software leider in den meisten Fällen nicht für uns übernehmen kann]. Hier: das 2-faktorielle Modell ist ein Spezialfall des 3-faktoriellen Modells):

```{r, results='hide'}
anova(two_factor_ML, three_factor_ML)
```

```{r, echo = F, purl=FALSE}
knitr::kable(anova(two_factor_ML, three_factor_ML), row.names = T)
```

Der $\chi^2$-Differenzwert liegt hier bei `r round(anova(two_factor_ML, three_factor_ML)[[4]][2], 3)` mit einen zugehörigen p-Wert von `r round(anova(two_factor_ML, three_factor_ML)[[5]][2], 3)`. `d.df` liegt bei `r anova(two_factor_ML, three_factor_ML)[[2]][2]` ($\Delta df$ =  `r anova(two_factor_ML, three_factor_ML)[[2]][2]`). Somit wird die Null-Hypothese, dass beide Modell die Daten gleich gut beschreiben, bzw. dass das sparsamere Modell die Daten genauso gut beschreiben kann, wie das komplexere Modell ($H_0:\Sigma_{3-Fakt.} = \Sigma_{2-Fakt.}$; im Gegensatz zum `anova`-Befehl, steht hier das komplexere Modell links), nicht verworfen. Aus diesem Grund entscheiden wir uns - Ockhams Rasiermesser folgend (siehe [Eid et al., 2017, p. 787](https://ubffm.hds.hebis.de/Record/HEB366849158)) - für das sparsamere Modell, also jenes, welches weniger Parameter enthält und somit restriktiver ist, hier: das *zweifaktorielle* Modell. Denn in der Wissenschaft streben wir danach, Modelle möglichst einfach zu halten!

Wenn Sie davon noch nicht genug haben, so können Sie in [Appendix B](#fivefactorML) nachlesen, wie eine EFA am gesamten (gekürzten) Datensatz durchgeführt wird. Dort stehen keine neuen Informationen zur Durchführung, Sie sollten es folglich eher als Übung ansehen, falls Sie sich entschließen, [Appendix B](#fivefactorML) durchzuarbeiten!

Die Zuordnung, die wir hier gefunden haben, entspringt der spezifischen Stichprobe, die wir untersucht haben. Wenn wir a priori aufgestellte Theorien über die Faktorstruktur prüfen wollen, können wir uns der [**konfirmatorischen Faktorenanalyse**](../fue-cfa) bedienen, die wir in der nächsten Sitzung betrachten.

***

## Appendix A {#AppendixA}
<details><summary> <b>Kürzen des Datensatzes</b> </summary>

Falls Sie die Originaldaten auf [<i class="fas fa-download"></i>  openpsychometrics.org](https://openpsychometrics.org/_rawdata/) als *.zip* herunterladen wollen, so können Sie diesen auf die hier verwendeten Daten wie folgt kürzen:
```{r, eval = F, echo = T}
data_full <- read.table("BIG5/data.csv", header = T, sep = "\t") # nach entpacken des .zip liegen die Daten in einem Ordner namens Big5

### Entferne leere Zeilen und Zeilen mit Missings aus dem Datensatz
ind <- apply(data_full, 1, FUN = function(x) any(is.na(x))) # erzeuge eine Variable, welche TRUE ist, wenn mindestens ein Eintrag pro Zeile fehlt und ansonsten FALSE anzeigt
data_full <- data_full[!ind, ] # Wähle nur diejenigen Zeilen, in denen unsere Indikatorvariable "ind" NICHT TRUE anzeigt, also wo alle Einträge vorhanden sind
# !ind (Ausrufezeichen vor ind) negiert die Einträge in ind (Prüfe bspw. !FALSE == TRUE, nicht false ist gleich true)

### Shorten Data Set
Big5 <- data_full[, c(2:4,7,7+rep(1:3,5)+sort(rep(seq(0,40,10),3)))]
 # Verwende nur 3 Items pro Skala plus einige demografische Items
Big5 <- data.frame(Big5) # Schreibe Datensatz als data.frame
save(list = c("Big5"), file = "Big5.rda")
# Speichere gekürzten Datensatz in .rda file (dem R-internen Datenformat)
## --> Das ist auch der Datensatz, den wir weiter verwendet haben!
```

</details>


## Appendix B {#fivefactorML}
<details><summary> <b>ML-EFA für den gesamten (gekürzten) Datensatz</b> </summary>

Für den vollen Datensatz mit jeweils drei Items pro Persönlichkeitsfacette, nehmen wir zunächst an, dass es 5 Faktoren gibt. Dies wird hier allerdings nicht durch die Parallelanalyse gestützt. Wir müssen die Funktion `fa.parallel` diesmal auf den vollen (gekürzten) Datensatz anwenden; nämlich auf `dataFR`.


```{r fig.height=6, fig.align="center", warning=FALSE}
fa.parallel(x = dataFR,fa = "fa")
```
Hier scheinen eher 4 Faktoren sinnvoll. Wir prüfen dennoch erstmal unsere inhaltliche Hypothese, dass es 5 Faktoren gibt, mit Hilfe der *oblique* Rotierten ML-EFA.

```{r}
five_factor_ML <- fa(dataFR, nfactors = 5, rotate = "oblimin", fm = "ml")
five_factor_ML$STATISTIC
five_factor_ML$PVAL # Modell wird durch die Daten nicht verworfen
```


Die Daten scheinen unserem Modell mit 5 Faktoren nicht zu widersprechen. Schauen wir uns die Faktorladungen an, um die Faktoren inhaltlich zu interpretieren.

```{r}
five_factor_ML$loadings # auch nochmal ohne [,] um die Ausblendehilfe von psych als Unterstützung für die Zuordnung zu nutzen
five_factor_ML$loadings[,] # alle Dezimalstellen anzeigen
```
Durch die Rotation sind auch hier die Faktoren anders nummeriert. Der erste Faktor ist hier *ML4* (dieser Faktor ist der erste in der Liste, da hier der Eigenwerte nach Rotation maximal ist; vor Rotation hatte *ML4* den viert größten Eigenwert). Die höchsten Faktorladungen mit diesem Faktor haben die Items $E_1$, $E_2$, $E_3$ und $A_2$. Somit könnte man diesen am ehesten *post-hoc* (die Theorie wird also aus den Daten generiert; es sind auch andere Interpretationsansätze zulässig) als Extraversion interpretieren. Allerdings scheinen die Items der Extraversion einiges mit jenen der Verträglichkeit ($A_{...}$) gemeinsam zu haben.
Dies könnte mit unter damit zusammen hängen, dass diese beiden Items am ehesten etwas mit sozialer Erwünschtheit zu tun haben.
Auf dem Faktor *ML3* laden vor allem die Items $N_1$ und $N_3$. Allerdings lädt $N_2$ besonders auf *ML1*.  
Dies könnte durchaus daran liegen, dass $N_1$ (*"I get stressed out easily."*) und $N_3$ (*"I worry about things."*) negativ kodiert sind, während $N_2$  (*"I am relaxed most of the time."*)  positiv kodiert ist und die erstgenannten Items somit mehr gemeinsam haben als die inhaltliche Zuordnung zum Neurotizismus. Somit scheint *ML3* ein Faktor der Sorgen, also des Neurotizismus zu sein, während *ML1* eher für einen Faktor der Gelassenheit spricht; beispielsweise laden hier auch positiv Items der Extraversion und Verträglichkeit. Das die Items des Neurotizismus auf unterschiedlichen Faktoren laden und unterschiedliche Vorzeichen aufweisen, kann für Methodeneffekte sprechen (*Unterschiede die zustande kommen, da unterschiedliche Methoden, hier: Itemformulierungen [positiv vs. negativ], verwendet werden.*). Auch auf *ML2* und *ML5* laden jeweils nur ein Item besonders stark: $O_1$ auf *ML2* und $C_2$ auf *ML5*. Insgesamt muss geschlussfolgert werden, dass zwar die fünffaktorielle Struktur durch die Daten nicht verworfen wird, aber dass die oblique rotierte Lösung keine eindeutige Zuordnung der Items aufweist. Allerdings bringt auch eine *varimax*-rotierte Lösung keine Verbesserung der Interpretierbarkeit, da diese neben der Einfachstruktur in der Faktorladungsmatrix noch die Unkorreliertheit der Faktoren berücksichtigen muss (in der *varimax*-rotierten Lösung sind dafür die Konstrukte nicht überlappend, was allerdings auch eine strenge Annahme ist):

```{r}
fa(dataFR, nfactors = 5, rotate = "varimax", fm = "ml")$loadings[,]
```

was wahrscheinlich daran liegt, dass die Kovariation zwischen den Faktoren nicht sehr groß ist:

```{r}
round(five_factor_ML$Phi, 2) # runde auf 2 Nachkommastellen
fa(dataFR, nfactors = 5, rotate = "varimax", fm = "ml")$Phi
```

`NULL` zeigt hierbei an, dass es das `$Phi` -Objekt nicht gibt. Tatsächlich ist die Kovarianzmatrix im orthogonalen Fall die Einheitsmatrix der Dimension $5\times5$:
{{< math >}}
$$\begin{pmatrix} 1& 0&0&0&0 \\ 0& 1&0&0&0 \\ 0& 0&1&0&0\\ 0& 0&0&1&0 \\ 0& 0&0&0&1 \end{pmatrix}$$
{{</ math >}}
In `R`:
```{r}
diag(5) # Einheitsmatrix der Dimension 5x5.
```


### Modellvergleich: ML-EFA
Wir schauen uns nun die Passung unseres Modells im Vergleich zu einem vier- und einem sechsfaktoriellen Modell an.


```{r}
four_factor_ML <- fa(dataFR, nfactors = 4, rotate = "oblimin", fm = "ml")
four_factor_ML$STATISTIC
four_factor_ML$PVAL
```

Das vierfaktorielle Modell wird durch die Daten verworfen ($p<0.05$). Nun zum Modellvergleich:

```{r, eval = F}
anova(four_factor_ML, five_factor_ML)
```

```{r, echo = F, purl=FALSE}
knitr::kable(anova(four_factor_ML, five_factor_ML), row.names = T)
```

Wir entscheiden uns hier nun für das fünffaktorielle Modell. Nun wollen wir uns das fünffaktorielle Modell noch im Vergleich zum sechsfaktoriellen Modell ansehen.


```{r}
six_factor_ML <- fa(dataFR, nfactors = 6, rotate = "oblimin", fm = "ml")
six_factor_ML$STATISTIC
six_factor_ML$PVAL # Modell wird durch die Daten nicht verworfen
```


Dem sechsfaktoriellen Modell widersprechen die Daten genauso wenig, wie dem fünffakoriellen (beide $p>0.05$). Dies war zu erwarten, da wir durch Hinzunahme des sechsten Faktors die Komplexität des Modell erhöht haben, wodurch sich das Modell stärker der konkreten Datenlage annähern kann. *Mehr Faktoren bedeuten immer eine detailgetreuere Abbildung der ursprünglichen Datenlage (siehe auch [Eid et al., 2017, Kapitel 25](https://ubffm.hds.hebis.de/Record/HEB366849158)).*


```{r, eval = F}
anova(five_factor_ML, six_factor_ML)
```

```{r, echo = F, purl=FALSE}
knitr::kable(anova(five_factor_ML, six_factor_ML), row.names = T)
```

Der $\chi^2$-Differenzwert liegt hier bei `r round(anova(five_factor_ML, six_factor_ML)[[4]][2], 3)` mit einen zugehörigen p-Wert von `r ifelse(anova(five_factor_ML, six_factor_ML)[[5]][2] < 0.01, "< 0.01", paste(round(anova(five_factor_ML, six_factor_ML)[[5]][2], 4)))` mit $\Delta df$ = `r anova(five_factor_ML, six_factor_ML)[[2]][2]`. Mit diesem Test wird geprüft, ob das sparsamere Modell die Daten schlechter abbildet. Die Nullhypothese ist also, dass das sparsamere Modell die Daten genauso gut beschreiben kann, wie das komplexere Modell ($H_0:\Sigma_{6-Fakt.} = \Sigma_{5-Fakt.}$). Da in diesem Fall der p-Wert größer als $.05$ ist, wird diese Nullhypothese nicht verworfen und wir entscheiden uns --- Ockhams Rasiermesser folgend (siehe [Eid et al., 2017, p. 787](https://ubffm.hds.hebis.de/Record/HEB366849158)) --- für das sparsamere Modell.

Wir hätten auch mehrere Tests gleichzeitig durchführen können. Allerdings sollten nicht beliebig konkurriende Theorien getestet werden --- Stichwort *Alpha-Inflation*!

```{r, eval = F}
anova(four_factor_ML, five_factor_ML, six_factor_ML)
```

```{r, echo = F, purl=FALSE}
knitr::kable(anova(four_factor_ML, five_factor_ML, six_factor_ML), row.names = T)
```

</details>


## Appendix C {#AppendixC}
<details><summary> <b>Faktorladungsmatrix vs. Strukturmatrix</b> </summary>

Um die Beziehung zwischen der Faktorladungsmatrix und der Strukturmatrix genauer zu verstehen, schauen wir uns das zweifaktorielle Modell für den (*standardisierten*) Datensatz `dataFR2` genauer an (*standardisiert* ist hier wichtig, da dies bedeutet, dass die Mittelwerte alle $0$ sind und wir somit diese ignorieren können):
{{< math >}}
$$\begin{pmatrix}E_1\\E_2\\E_3\\N_1\\N_2\\N_3 \end{pmatrix} = \begin{pmatrix}
\lambda_{11} & \lambda_{12}\\
\lambda_{21} & \lambda_{22}\\
\lambda_{31} & \lambda_{32}\\
\lambda_{41} & \lambda_{42}\\
\lambda_{51} & \lambda_{52}\\
\lambda_{61} & \lambda_{62} \end{pmatrix}  \begin{pmatrix}\xi_1\\\xi_2 \end{pmatrix} +  \begin{pmatrix}\varepsilon_{E_1}\\\varepsilon_{E_2}\\\varepsilon_{E_3}\\\varepsilon_{N_1}\\\varepsilon_{N_2}\\\varepsilon_{N_3} \end{pmatrix}$$
{{</ math >}}

Dies ist die Messmodellsgleichung, welche die Beziehung zwischen den latenten Variablen und den Messfehlern mit den beobachtbaren Variablen beschreibt. Die Faktorladungsmatrix $\Lambda$ enthält hier die Gewichtung der latenten Variablen und bestimmt somit, wie groß der Anteil jeder latenten Variable an der Messung ist (dies ist ähnlich der Reliabilität zu bewerten). Die Strukturmatrix beschreibt die Korrelation/Kovariation zwischen Messung und latenter Variable und enthält somit zusätzliche Informationen über die Beziehungen der latenten Variablen untereinander.

[Im Abschnitt zur Hauptachsenanalyse](#Hauptachsenanalyse) hatten wir erkannt, dass der erste Faktor wahrscheinlich der Extraversion und der zweite wahrscheinlich dem Neurotizismus entspricht. Demnach könnten wir $\xi_1=\xi_\text{Extraversion}$ und $\xi_2=\xi_\text{Neurotizismus}$ nennen. Bennen wir nun die Faktorladungsmatrix als $\Lambda$ und die Korrelationsmatrix der latenten Variablen $\Phi$ (die Diagonaleinträge sind $1$).
Die Kovarianz zwischen dem ersten Extraversionsitem und dem Extraversionsfaktor ist folgendermaßen zu berechnen (wir rechnen hier mit Kovarianzen, da dies im Allgemeinen deutlich einfacher ist, als mit Korrelationen  zu rechen. Außerdem sind hier alle Variablen standardisiert und somit sind Korrelation und Kovarianz identisch; über die Rechenregeln und die Beziehungen zwischen Korrelation und Kovarianz können sie in [Eid, et al. (2017)](https://ubffm.hds.hebis.de/Record/HEB366849158) S. 195-196 und folgend und S.570-571 und folgend nachlesen):
{{< math >}}
$$\begin{align}\mathbf{C}ov[E_1, &\xi_1]\\&= \mathbf{C}ov[\lambda_{11}\xi_1 + \lambda_{12}\xi_2+\varepsilon_{E_1}, \xi_1]\\ &= \lambda_{11}\mathbf{C}ov[\xi_1, \xi_1] + \lambda_{12}\mathbf{C}ov[\xi_2, \xi_1] +\mathbf{C}ov[\varepsilon_{E_1}, \xi_1]\\ &= \lambda_{11}\mathbb{V}ar[\xi_1] + \lambda_{12}\mathbf{C}ov[\xi_2, \xi_1]\\ &= \lambda_{11}\phi_{11} + \lambda_{12}\phi_{21}\\&= \lambda_{11} + \lambda_{12}\phi_{21}\end{align}$$
{{</ math >}}

$\mathbf{C}ov[\varepsilon_{E_1}, \xi_1]=0$ gilt, da die Fehler als unabhängig von allen weiteren Variablen im Modell angenommen werden. Außerdem sind $\phi_{11}=1$ und $\mathbb{C}ov[\xi_1,\xi_2]=\phi_{21}=\phi_{12}=\mathbb{C}ov[\xi_2,\xi_1]$ die Varianz von $\xi_1$ und die Kovarianz/Korrelation zwischen $\xi_1$ und $\xi_2$ und entsprechend Einträge von $\Phi$. Aus dieser Rechnung folgt, dass der erste Eintrag in der Strukturmatrix (an der Stelle 1. Zeile, 1. Spalte) $\lambda_{11} + \lambda_{12}\phi_{21}$ sein muss. Hier ist zu erkennen, dass falls die Korrelation zwischen den latenten Variablen als $0$ angenommen wird (im orthogonalen Fall gilt dann $\phi_{21}=\phi_{12}=0$), dann ist die Strukurmatrix gleich der Faktorladungsmatrix und der erste Eintrag lautet $\lambda_{11}$. Wir schauen uns dies empirisch für das orthogonale Modell (bereits geschätzt in `two_factor`) und das oblique-rotiert geschätzte Modell (bereits geschätzt in `two_factor_oblimin`) an.
Im orthogonalen Fall ist dies etwas unspannend:
```{r}
two_factor$loadings[1, 1] # volle Formel für ersten Eintrag in Strukutrmatrix, da Kovarianz der Faktoren = 0
two_factor$Structure[1, 1] # erster Eintrag in der Strukturmatrix
```
Offensichtlich sind beide Einträge gleich, was daran liegt, dass die Faktoren als unkorreliert angenommen werden. Nun zum oblique rotierten Fall:

```{r}
two_factor_oblimin$loadings[1, 1] # erste Faktorladung im obliquen Modell (unterscheidet sich von dem ersten Eintrag der Strukturmatrix)
two_factor_oblimin$loadings[1, 1] + two_factor_oblimin$loadings[1, 2]*two_factor_oblimin$Phi[2, 1] # volle Formel für ersten Eintrag in Strukutrmatrix
two_factor_oblimin$Structure[1, 1] # erster Eintrag in der Strukturmatrix
```
Hier ist zu sehen, dass sich Faktorladungsmatrix und Strukturmatrix unterscheiden. Der Unterschied ist nicht sehr hoch, da die Korrelation zwischen den beiden Faktoren lediglich bei {{< math >}}$\hat{\phi}_{21}${{</ math >}}=`r round(two_factor_oblimin$Phi[2, 1], 4)` liegt und somit {{< math >}}$\hat{\lambda}_{12}\hat{\phi}_{21}=${{</ math >}} `r round(two_factor_oblimin$loadings[1, 2]*two_factor_oblimin$Phi[2, 1], 4)` keine große Veränderung zu {{< math >}}$\hat{\lambda}_{11}${{</ math >}} mit sich bringt. In Matrixschreibweise lässt sich die Strukturmatrix unkompliziert bestimmen. Sie wird durch folgenden Ausdruck berechnet:
$$\Lambda\Phi$$
Dies können wir in `R` leicht empirisch überprüfen. Einen Überblick über die Befehle für Matrix-Algebra in `R` finden Sie auf der [Quick-R Website](https://www.statmethods.net/advstats/matrix.html), auf welche bereits in der Sitzung zu [Einführung in `lavaan`](../lavaan-intro) aufmerksam gemacht wurde. Außerdem ist im [Appendix B](../../fue-i/einleitung-fue/#EinleitungAppendixBMatrixalgebra) der [Einführungssitzung zu PsyMSc1](../../fue-i/einleitung-fue) bereits eine Einführung in Matrixalgebra gegeben worden. Wir berechnen nun das Matrixprodukt für den oblique rotieren Fall:

```{r}
two_factor_oblimin$loadings[,] %*% two_factor_oblimin$Phi[,] # Matrixprodukt
two_factor_oblimin$Structure[,] # Strukturmatrix
```
`%*%` signalisiert `R`, dass ein Matrixprodukt und *keine* komponentenweise Mulitplikation durchzuführen ist. `[,]` sorgt dafür, dass nur die Matrizen verwendet werden und nicht der zusätzliche Output, der ggf. durch das `psych`-Paket mit ausgegeben wird.

Das ganze funktioniert selbstverständlich auch für den fünffaktoriellen oblique rotierten ML-EFA Fall, den wir uns später angesehen haben, als es darum ging, den [gesamten (gekürzten) Datensatz mit Hilfe der ML-EFA](#fivefactorML) zu untersuchen. Das zugehörige Objekt, welches das geschätzte Modell enthält, heißt `five_factor_ML`:

```{r}
five_factor_ML$loadings[,] %*% five_factor_ML$Phi[,] # Matrixprodukt
five_factor_ML$Structure[,] # Strukturmatrix
```

Hier alle Einträge auf Gleichheit zu untersuchen, ist sehr mühsam. Wir können dies viel einfacher mit einer Differenz tun:

```{r}
five_factor_ML$loadings[,] %*% five_factor_ML$Phi[,] - five_factor_ML$Structure[,]
```
Da hier nur Nullen herauskommen, scheinen die Ausdrücke identisch zu sein!

</details>

## Appendix D {#AppendixD}
<details><summary> <b>Berechnen von Eigenwerten und Kommunalitäten mit Hilfe von $\Lambda$ und $\Phi$</b> </summary>

Im vorigen Abschnitt hatten wir bemerkt, wie leicht die Strukturmatrix aus der Faktorladungsmatrix $\Lambda$ hervorgeht, indem einfach nur die Beziehung der latenten Variablen untereinander berücksichtigt wird. Es ist folglich nur logisch, dass bei der Bestimmung der Eigenwerte und der Kommunalitäten diese Beziehung ebenfalls eine Rolle spielt. Im Rahmen der [PCA](/lehre/fue-i/pca) hatten wir uns bereits die Beziehungen dieser Größen untereinander angesehen. Dort war es so, dass die Diagonalelemente von $\Lambda\Lambda'$ gerade die Kommunalitäten waren und die Diagonalelemente von $\Lambda'\Lambda$ gerade die Eigenwerte der rotierten Lösung. Es kam also lediglich darauf an, in welcher Reihenfolge $\Lambda$ und transponiertes $\Lambda$ miteinander verrechnet werden! Für oblique rotierte EFAs müssen wir nun noch die Korrelation der Faktoren untereinander berücksichtigen. Die implizierte Korrelationsmatrix war einfach
$$\Lambda\Phi\Lambda' + \Theta,$$
wobei die Elemente von $\Theta$ im Grunde nur dafür sorgen, dass die Hauptdiagonale wieder bei 1 landet. Lassen wir $\Theta$ weg, erhalten wir die Korrelationsmatrix mit den Kommunalitäten auf der Hauptdiagonale. Damit ist klar, dass
$$\text{diag}(\Lambda\Phi\Lambda') = \text{Kommunalitäten}$$
gilt. Da wir bereits wissen, dass  $\Lambda\Phi$ die Strukturmatrix ist, könnten wir auch einfach sagen, dass das Matrixprodukt *Strukturmatrix Faktorladungsmatrix'* die Kommunalitäten auf der Hauptdiagonale enthält. Probieren wir dies doch einmal aus:

```{r}
two_factor_ML$communality
diag(two_factor_ML$loadings[,] %*% two_factor_ML$Phi[,] %*% t(two_factor_ML$loadings[,]))
diag(two_factor_ML$Structure[,] %*% t(two_factor_ML$loadings[,]))
```

In allen 3 Fällen kommen die Kommunalitäten heraus. `diag` fordert hierbei die Diagonalelemente einer quadratischen Matrix an. Um nun die Eigenwerte zu erhalten, müssen wir das Matrixprodukt nur umdrehen: *Faktorladungsmatrix' Strukturmatrix*, bzw. das Transponierungszeichen tauschen (*Strukturmatrix' Faktorladungsmatrix* ginge auch!):

$$\text{diag}(\Phi\Lambda'\Lambda) = \text{Eigenwerte}$$
Wer genau aufpasst, fragt sich jetzt vielleicht, wieso $\Phi$ kein Transponierungszeichen trägt. Das liegt daran, dass eine Kovarianz/Korrelationsmatrix immer symmetrisch ist --- die Definition einer symmetrischen quadratischen Matrix $A$ ist: $A = A'$.

```{r}
two_factor_ML$Vaccounted # Eigenwerte nach Rotation und Extraktion in SS loadings
diag(two_factor_ML$Phi[,] %*% t(two_factor_ML$loadings[,])  %*% two_factor_ML$loadings[,])
diag(t(two_factor_ML$Structure[,]) %*% two_factor_ML$loadings[,])
```

In der ersten Zeile von `two_factor_ML$Vaccounted` stehen die Eigenwerte nach Rotation und Extraktion. Diese sind identisch zur Diagonale der beiden Matrixprodukte!

</details>

## Appendix E {#AppendixE}
<details><summary> <b>Prüfen der Voraussetzungen mit der Mahalanobisdistanz und Mardia's Test</b> </summary>
Auf multivariate Normalverteilung können wir beispeilsweise **deskriptiv** prüfen, indem wir die Mahalanobisdistanz (die Distanz vom gemeinsame Zentroiden; dem Mittelwert über alle Variablen; unter Berücksichtigung der Kovariation im Datensatz) plotten und sie mit einer $\chi^2$-Verteilung vergleichen; wobei $df=p$ und $p=$ Anzahl an Variablen (hier $df=p=15$).
```{r}
Mahalanobis_Distanz <- mahalanobis(x = dataFR, cov = cov(dataFR), center = colMeans(dataFR)) # Berechnen der Mahalanobisdistanz
hist(Mahalanobis_Distanz, col = "skyblue", border = "blue", freq = F, breaks = 15) # Histogramm
lines(x = seq(0, max(Mahalanobis_Distanz), 0.01), y = dchisq(x = seq(0, max(Mahalanobis_Distanz), 0.01), df = 15), col = "darkblue", lwd = 4) # Einzeichnen der Dichte
```

*Sie können ja mal Einstellungen verändern und sich deren Konsequenz für die Grafik ansehen!*

Das Histogramm scheint nicht perfekt zur $\chi^2$-Verteilung zu passen. Allerdings sind die Abweichungen auch nicht enorm. Wir verwerfen auf Basis des Histogramms die Normalverteilungsannahme nicht, sollten die Ergebnisse aber trotzdem unter Vorbehalt interpretiert werden.


Die Funktion `mahalanobis` berechnet die Mahalanobisdistanz pro Proband:in. Als Datenargument braucht sie eine Matrix `x`. Die Mahalanobisdistanz ist ein Distanzmaß, welches die korrelative Struktur in den Daten berücksichtigt. Wir übergeben daher mit `cov = cov(dataFR)` der Funktion `mahalanobis` die empirische Kovarianzmatrix unserer Daten (`cov(dataFR)`), um diese Struktur mit zuberücksichtigen. Außerdem müssen die Variablen und deren Variation relativ zu einem Zentroiden angegeben werden. Der Zentroid wird dem `center`-Argument übergeben. Wir brauchen also für jede Variable deren Mittelwert. Dies machen wir mit `colMeans`.

```{r}
colMeans(dataFR)
```

Der `hist`-Befehl erzeugt schließlich ein Histogramm der Mahalanobisdistanzen. Mit den Argumenten `col = "skyblue"` und `border = "blue"` setzten wir die Farben des Histogramms fest. Mit `freq = F` sagen wir, dass wir nicht die absoluten sondern die relativen Häufigkeiten angezeigt haben wollen (dies brauchen wir um anschließend die Dichte der $\chi^2$-Verteilung einzuzeichnen). Mit `breaks = 15` beschließen wir, dass insgesamt ca. 15 Balken gezeichnet werden sollen.

Schließlich zeichnen wir mit `lines` eine Line, welche als x-Argument `x = seq(0, max(Mahalanobis_Distanz), 0.01)` eine Sequenz von Zahlen von 0 bis zur maximalen Mahalanobisdistanz erhält und in 0.01 Schritten wächst. Gegen diese x-Werte zeichnen wir die Dichte der $\chi^2(df=15)$-Verteilung ein: ` y = dchisq(x = seq(0, max(Mahalanobis_Distanz), 0.01), df = 15)`. `col = "darkblue"` und `lwd = 4` setzten jeweils die Linienfarbe und Liniendicke fest. Weitere Informationen zu Verteilungen  und wie man diese in `R` umsetzt, können im [R-Wiki zu Verteilungen](https://en.wikibooks.org/wiki/R_Programming/Probability_Distributions), in [Wikipedia zu Verteilungen und Dichten](https://de.wikipedia.org/wiki/Wahrscheinlichkeitsdichtefunktion) oder in einer [Kurzzusammenfassung auf statmethods](https://www.statmethods.net/advgraphs/probability.html) nachgelesen werden. Grundlagen hierzu können außerdem in [Eid et al. (2017)](https://ubffm.hds.hebis.de/Record/HEB366849158) in Kapitel 7 ab Seite 171 gefunden werden.

Außerdem können wir auch noch Mardia's Test auf multivariate Normalverteilung verwenden. Diesen gibt es bspw. im `R`-Paket `MVN` (für **M**ulti-**V**ariate **N**ormal-distribution). In diesem Paket verwenden wir die `mvn`-Funktion, um Mardia's Test zu verwenden:

```{r, message = F}
library(MVN)
mvn(data = dataFR, mvnTest = "mardia")
```

Hier bekommen wir einiges an Output. Der erste Block enthält den Test auf multivariate Normalität (unter `$multivariateNormality`). Der nächste Unterpunkt enthält Informationen zur univariate Normalität  (unter `$univariateNormality`) sowie einen Block zu Deskriptivstatistiken (unter `$Descriptives`). Wir konzentrieren uns nur auf den multivariaten Test:

```{r, echo = F, purl=FALSE}
cat('## $multivariateNormality
##              Test        Statistic              p value Result
## 1 Mardia Skewness 814.236119391994 0.000288124299329737     NO
## 2 Mardia Kurtosis 1.53049602635342    0.125893996300673    YES
## 3             MVN             <NA>                 <NA>     NO
## ')
```

In der ersten Spalte steht der Test `Mardia Skewness` oder `Mardia Kurtosis`, wo mit multivariater Schiefe (Skewness) und Kurtosis (Wölbung) untersucht wird, ob diese von der Normalverteilung abweichen. `Statistic` enthält Informationen zu Mardia's Teststatistik, welche auch einen zugehörigen `p value` hat. Unter `Result` steht eine Entscheidung, ob die Schiefe oder Wölbung jeweils von einer Normalverteilung stammen könnte. Ganz unten steht `MVN`, also eine globale Entscheidung. Hier steht leider `NO`, also kann nicht von multivariater Normalverteilung gesprochen werden, denn die Null-Hypothese, dass die Daten die selbe multivariate Schiefe und Wölbung wie die einer Normalverteilung aufzeigen, musste auf dem $\alpha=5\%$ Niveau verworfen werden. Dieser Test wird auch kurz in [Eid et al. (2017, pp. 516-517)](https://ubffm.hds.hebis.de/Record/HEB366849158) beschrieben. Für unsere Ergebnisse bedeutet dies, dass Parameter ggf. verzerrt sind und der Likelihood-Ratio-Test ggf. zu falschen Schlüssen kommt! Die Ergebnisse dieser Sitzung sind also nur unter Vorbehalt zu interpretieren.

</details>



## Literatur
[Brandt H. (2020).](https://ubffm.hds.hebis.de/Record/HEB468515836) Exploratorische Faktorenanalyse (EFA). In [Moosbrugger H., Kelava A.](https://ubffm.hds.hebis.de/Record/HEB468515836) (eds) Testtheorie und Fragebogenkonstruktion. Berlin, Heidelberg: Springer. [https://doi.org/10.1007/978-3-662-61532-4_23](https://doi.org/10.1007/978-3-662-61532-4_23)


[Eid, M., Gollwitzer, M., & Schmitt, M. (2017).](https://ubffm.hds.hebis.de/Record/HEB366849158) *Statistik und Forschungsmethoden* (5. Auflage, 1. Auflage: 2010). Weinheim: Beltz.


* <small> <i>Blau hinterlegte Autor:innenangaben führen Sie direkt zur universitätsinternen Ressource.</i> </small>
